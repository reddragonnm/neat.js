function sigmoid(t){return 1/(1+Math.exp(-t))}function linear(t){return t}function sum(t){return t.reduce((t,n)=>t+n,0)}function randUniform(){return 2*Math.random()-1}function randChoice(t){return t[Math.floor(Math.random()*t.length)]}class Innovation{constructor(t,n,e,s,o){this.innov=t,this.newConn=n,this.fr=e,this.to=s,this.nodeId=o}}class InnovTable{static setNodeId(t){this.nodeId=Math.max(this.nodeId,t)}static createInnov(t,n,e){let s=null;e||(s=this.nodeId++);const o=new Innovation(this.innov++,e,t,n,s);return this.history.push(o),o}static getInnov(t,n,e=!0){for(let s of this.history)if(s.newConn==e&&s.fr==t&&s.to==n)return s;return InnovTable.createInnov(t,n,e)}}InnovTable.history=[],InnovTable.innov=0,InnovTable.nodeId=0;class Options{}var NodeState;Options.fitnessThreshold=1/0,Options.maxNodes=1/0,Options.activation=sigmoid,Options.aggregation=sum,Options.excessCoeff=1,Options.disjointCoeff=1,Options.weightCoeff=.5,Options.addNodeProb=.07,Options.addConnProb=.2,Options.weightMutateProb=.1,Options.newWeightProb=.1,Options.weightInitRange=1,Options.weightMutatePower=.5,Options.featureSelection=!1,Options.compatThresh=3,Options.dynamicCompatThresh=!0,Options.targetSpecies=20,Options.dropoffAge=15,Options.survivalRate=.2,Options.speciesElitism=!0,Options.crossoverRate=1,Options.triesTournSel=3,Options.youngAgeThresh=10,Options.youngAgeFitnessBonus=1.3,Options.oldAgeThresh=50,Options.oldAgeFitnessPenalty=.7,function(t){t.input="input",t.hidden="hidden",t.bias="bias",t.output="output"}(NodeState||(NodeState={}));class NodeGen{constructor(t,n,e,s){this.id=t,this.state=n,this.x=e,this.y=s,this.val=0}copy(){return new NodeGen(this.id,this.state,this.x,this.y)}}class ConnectionGen{constructor(t,n,e,s=null,o=!0){this.fr=t,this.to=n,this.weight=null===s?randUniform()*Options.weightInitRange:s,this.enabled=o,this.innov=e}copy(){return new ConnectionGen(this.fr,this.to,this.innov,this.weight,this.enabled)}}class Brain{constructor(t,n=null,e=null){if(this.id=t,this.fitness=0,this.nodes=n,this.connections=e,null!==n)return void this.nodes.sort((t,n)=>t.id-n.id);const s=1/(Options.numInputs+1),o=1/Options.numOutputs;let i=0;const h=[],a=[],r=[new NodeGen(i++,NodeState.bias,.5*s,0)];for(let t=0;t<Options.numInputs;t++)h.push(new NodeGen(i++,NodeState.input,(t+1.5)*s,0));for(let t=0;t<Options.numOutputs;t++)a.push(new NodeGen(i++,NodeState.output,(t+.5)*o,1));if(this.nodes=r.concat(h.concat(a)),InnovTable.setNodeId(i),this.connections=[],Options.featureSelection){const t=randChoice(r.concat(h)),n=randChoice(a);this.connections.push(new ConnectionGen(t.id,n.id,InnovTable.getInnov(t.id,n.id).innov))}else for(let t of r.concat(h))for(let n of a)this.connections.push(new ConnectionGen(t.id,n.id,InnovTable.getInnov(t.id,n.id).innov))}getDrawInfo(){const t={nodes:{input:[],hidden:[],output:[],bias:[]},connections:{enabled:[],disabled:[]}};for(let n of this.nodes)t.nodes[n.state].push({id:n.id,pos:[n.x,n.y]});for(let n of this.connections){const e=this.getNode(n.fr),s=this.getNode(n.to),o=n.enabled?"enabled":"disabled";t.connections[o].push({fr:[e.x,e.y],to:[s.x,s.y],weight:n.weight})}return t}addConn(){const t=[];for(let n of this.nodes)for(let e of this.nodes)this.validConn(n,e)&&t.push([n.id,e.id]);if(t.length){let[n,e]=randChoice(t);this.connections.push(new ConnectionGen(n,e,InnovTable.getInnov(n,n).innov))}}addNode(){const t=this.connections.filter(t=>t.enabled&&0!=t.fr);if(!t.length)return;const n=randChoice(t),e=this.getNode(n.fr),s=this.getNode(n.to),o=InnovTable.getInnov(n.fr,n.to,!1).nodeId;n.enabled=!1,this.nodes.push(new NodeGen(o,NodeState.hidden,(e.x+s.x)/2,(e.y+s.y)/2)),this.connections=this.connections.concat([new ConnectionGen(n.fr,o,InnovTable.getInnov(n.fr,o).innov,1),new ConnectionGen(o,n.to,InnovTable.getInnov(o,n.to).innov,n.weight)])}mutate(){Math.random()<Options.addNodeProb&&this.nodes.length<Options.maxNodes&&this.addNode(),Math.random()<Options.addConnProb&&this.addConn();for(let t of this.connections)Math.random()<Options.weightMutatePower&&(Math.random()<Options.newWeightProb?t.weight=randUniform()*Options.weightInitRange:t.weight+=randUniform()*Options.weightMutatePower)}getInputConnections(t){return this.connections.filter(n=>n.to==t)}getNode(t){return this.nodes.filter(n=>n.id==t)[0]}validConn(t,n){return!this.connections.filter(e=>e.fr==t.id&&e.to==n.id).length&&t.id!=n.id&&[NodeState.input,NodeState.hidden,NodeState.bias].includes(t.state)&&[NodeState.hidden,NodeState.output].includes(n.state)&&t.y<=n.y}predict(t){t.length!=Options.numInputs&&console.error("Number of inputs do not match with the number declared in Options");const n=new Set(this.nodes.map(t=>t.y)).size;for(let t of this.nodes)t.val=0;for(let e=0;e<n;e++){let n=0;for(let e of this.nodes)if(e.state==NodeState.input)e.val=t[n++];else if(e.state==NodeState.bias)e.val=1;else{const t=[];for(let n of this.getInputConnections(e.id))n.enabled&&t.push(n.weight*this.getNode(n.fr).val);e.val=Options.activation(Options.aggregation(t))}}return this.nodes.filter(t=>t.state==NodeState.output).map(t=>t.val)}static crossover(t,n,e){const s=t.connections.length,o=n.connections.length;let i;i=t.fitness==n.fitness?s==o?randChoice([t,n]):s<o?t:n:t.fitness>n.fitness?t:n;const h=[],a=[],r=[];let c=0,l=0;for(;c<s||l<o;){const e=c<s?t.connections[c]:null,p=l<o?n.connections[l]:null;let d,u;if(null!==e&&null!==p?e.innov==p.innov?([d,u]=randChoice([[e,t],[p,n]]),c++,l++):p.innov<e.innov?(i===n&&(d=n.connections[l],u=n),l++):e.innov<p.innov&&(i===t&&(d=e,u=t),c++):null===e&&null!==p?(i===n&&(d=n.connections[l],u=n),l++):null!==e&&null==p&&(i===t&&(d=e,u=t),c++),d&&u){let t;a.push(d.copy()),r.includes(d.fr)||(t=u.getNode(d.fr))&&(h.push(t.copy()),r.push(d.fr)),r.includes(d.to)||(t=u.getNode(d.to))&&(h.push(t.copy()),r.push(d.to))}}return new Brain(e,h,a)}}class Species{constructor(t,n){this.id=t,this.best=n,this.pool=[n],this.age=0,this.stagnation=0,this.spawnsReq=0,this.maxFitness=0,this.avgFitness=0}purge(){this.age++,this.stagnation++,this.pool=[]}getBrain(){let t=this.pool[0];for(let n=0;n<Math.min(this.pool.length,Options.triesTournSel);n++){const n=randChoice(this.pool);n.fitness>t.fitness&&(t=n)}return t}cull(){this.pool=this.pool.slice(0,Math.max(1,Math.round(this.pool.length*Options.survivalRate)))}adjustFitnesses(){this.avgFitness=0;for(let t of this.pool){let n=t.fitness;this.age<Options.youngAgeThresh&&(n*=Options.youngAgeFitnessBonus),this.age>Options.oldAgeThresh&&(n*=Options.oldAgeFitnessPenalty),this.avgFitness+=n/this.pool.length}}makeLeader(){this.pool.sort((t,n)=>n.fitness-t.fitness),this.best=this.pool[0],this.best.fitness>this.maxFitness&&(this.stagnation=0,this.maxFitness=this.best.fitness)}static compatDist(t,n){let e=0,s=0,o=0,i=0;const h=t.connections.length,a=n.connections.length;let r=0,c=0;for(;r<h||c<a;){if(r==h){o++,c++;continue}if(c==a){o++,r++;continue}const l=t.connections[r],p=n.connections[c];l.innov!=p.innov?l.innov<p.innov?(s++,r++):l.innov>p.innov&&(s++,c++):(e++,r++,c++,i+=Math.abs(l.weight-p.weight))}return e++,(Options.excessCoeff*o+Options.disjointCoeff*s)/Math.max(h,a)+Options.weightCoeff*i/e}sameSpecies(t){return Species.compatDist(t,this.best)<=Options.compatThresh}}class Population{constructor(){this.pool=Array(Options.popSize).fill(0).map((t,n)=>new Brain(n)),this.best=this.pool[0],this.species=[],this.gen=0,this.brainId=this.pool.length,this.speciesId=0}data(){return`${this.gen}, ${this.best.fitness}`}evaluate(t,n=1/0,e=!0){for(;;){if(t(this.pool),this.epoch(),e&&console.log(this.data()),this.best.fitness>=Options.fitnessThreshold)return[this.best,!0];if(this.gen>=n)return[this.best,!1]}}speciate(){for(let t of this.pool){let n=!1;for(let e of this.species)if(e.sameSpecies(t)){e.pool.push(t),n=!0;break}n||this.species.push(new Species(this.speciesId++,t))}this.species=this.species.filter(t=>t.pool.length>0)}calcSpawns(){const t=Math.max(1,this.species.reduce((t,n)=>t+n.avgFitness,0));for(let n of this.species)n.spawnsReq=Options.popSize*n.avgFitness/t}reproduce(){this.pool=[];for(let t of this.species){const n=[];for(Options.speciesElitism&&n.push(t.best);n.length<t.spawnsReq;){const e=t.getBrain();let s;if(Math.random()<Options.crossoverRate){const n=t.getBrain();s=Brain.crossover(e,n,this.brainId++)}else s=Brain.crossover(e,e,this.brainId++);s.mutate(),n.push(s)}this.pool=this.pool.concat(n),t.purge()}for(;this.pool.length<Options.popSize;)this.pool.push(new Brain(this.brainId++))}sortPool(){this.pool.sort((t,n)=>n.fitness-t.fitness),this.pool[this.pool.length-1].fitness<0&&console.error("Cannot handle negative values"),this.best.fitness<this.pool[0].fitness&&(this.best=this.pool[0])}adjustFitnesses(){for(let t of this.species)t.makeLeader(),t.adjustFitnesses()}changeCompatThresh(){this.species.length<Options.targetSpecies?Options.compatThresh*=.95:this.species.length>Options.targetSpecies&&(Options.compatThresh*=1.05)}resetAndKill(){const t=[];for(let n of this.species)n.stagnation>Options.dropoffAge||0==n.spawnsReq||(n.cull(),t.push(n));this.species=t}epoch(){this.sortPool(),this.speciate(),Options.dynamicCompatThresh&&this.changeCompatThresh(),this.adjustFitnesses(),this.calcSpawns(),this.resetAndKill(),this.reproduce(),this.gen++}}